<!doctype html>
<html lang="en">
  <head>
  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Upload and parse CSV in ClojureScript</title>
  <meta name="author" content="Michael McClintock">
  <meta name="description" content="">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <link href='https://fonts.googleapis.com/css?family=Muli|Source+Code+Pro' rel='stylesheet' type='text/css'>
  <link rel="stylesheet" href="/compiled-css/main.css">
</head>

  <body class="site">
    <nav class="site-nav">
  <a class="site-nav-item" href="/">mrmcc3</a>
  <a class="site-nav-item" href="/about">about</a>
  <a class="site-nav-spacer"></a>
  <a class="site-nav-item" href="https://github.com/mrmcc3"><i class="fa fa-github"></i></a>
  <a class="site-nav-item" href="https://twitter.com/mrmcc3"><i class="fa fa-twitter"></i></a>
  <a class="site-nav-item" href="/post/index.xml"><i class="fa fa-feed"></i></a>
</nav>

    <section class="post text-justify">
      <h3 class="title">Upload and parse CSV in ClojureScript</h1>
      <span class="date">11-Jun-2016</span>
      <article class="content">
         

<p>Here&rsquo;s the scenario: Upload a <a href="https://en.wikipedia.org/wiki/Comma-separated_values">CSV</a> file from your computer, parse it,
slice/dice/massage it into a form worth rendering, shove it in the DOM
for your viewing pleasure and then print it. I had the need to do this
recently for a friend. So here&rsquo;s the result.</p>

<p>First off, doing any data transformation in javascript isn&rsquo;t my
idea of fun. I&rsquo;d rather use immutable data structures and a well
thought out standard lib. So ClojureScript it is.</p>

<h4 id="rendering-the-upload-button">Rendering the upload button</h4>

<p>Let&rsquo;s start by defining some data driven components with <a href="https://reagent-project.github.io/">reagent</a>.</p>
<div class="highlight"><pre><code class="language-clojure" data-lang="clojure"><span></span><span class="p">(</span><span class="kd">defn </span><span class="nv">upload-btn</span> <span class="p">[</span><span class="nv">file-name</span><span class="p">]</span>
  <span class="p">[</span><span class="ss">:span.upload-label</span>
   <span class="p">[</span><span class="ss">:label</span>
    <span class="p">[</span><span class="ss">:input.hidden-xs-up</span> 
     <span class="p">{</span><span class="ss">:type</span> <span class="s">&quot;file&quot;</span> <span class="ss">:accept</span> <span class="s">&quot;.csv&quot;</span> <span class="ss">:on-change</span> <span class="nv">put-upload</span><span class="p">}]</span>
    <span class="p">[</span><span class="ss">:i.fa.fa-upload.fa-lg</span><span class="p">]</span>
    <span class="p">(</span><span class="nb">or </span><span class="nv">file-name</span> <span class="s">&quot;click here to upload and render csv...&quot;</span><span class="p">)]</span>
   <span class="p">(</span><span class="nb">when </span><span class="nv">file-name</span> 
     <span class="p">[</span><span class="ss">:i.fa.fa-times</span> <span class="p">{</span><span class="ss">:on-click</span> <span class="o">#</span><span class="p">(</span><span class="nf">reset!</span> <span class="nv">app-state</span> <span class="p">{})}])])</span>
</code></pre></div>

<p>By hiding the input and wrapping it in a label we can customize the
look of the button. Also note the component is passed the <code>file-name</code> which is
used to indicate the current uploaded file.</p>

<div id="csv-upload-imgs">
<img src="/images/post/csv-with-clojurescript/upload2.png"></img>
<img src="/images/post/csv-with-clojurescript/upload1.png"></img>
</div>

<p>Below is the root component (called <code>app</code>) which just dereferences and destructures
the <code>app-state</code> then feeds the requisite parts to the sub components.</p>
<div class="highlight"><pre><code class="language-clojure" data-lang="clojure"><span></span><span class="p">(</span><span class="kd">defn </span><span class="nv">app</span> <span class="p">[]</span>
  <span class="p">(</span><span class="k">let </span><span class="p">[{</span><span class="ss">:keys</span> <span class="p">[</span><span class="nv">file-name</span> <span class="nv">data</span><span class="p">]</span> <span class="ss">:as</span> <span class="nv">state</span><span class="p">}</span> <span class="o">@</span><span class="nv">app-state</span><span class="p">]</span>
    <span class="p">[</span><span class="ss">:div.app</span>
     <span class="p">[</span><span class="nv">flyout</span> <span class="nv">state</span><span class="p">]</span>
     <span class="p">[</span><span class="ss">:div.topbar.hidden-print</span> 
      <span class="p">[</span><span class="nv">upload-btn</span> <span class="nv">file-name</span><span class="p">]]</span>
     <span class="p">[</span><span class="nv">report</span> <span class="nv">data</span><span class="p">]]))</span>

<span class="p">(</span><span class="nf">r/render-component</span> <span class="p">[</span><span class="nv">app</span><span class="p">]</span> <span class="p">(</span><span class="nf">js/document.getElementById</span> <span class="s">&quot;app&quot;</span><span class="p">))</span>
</code></pre></div>

<p>So far so good. The <code>report</code> component renders the <code>data</code>. The <code>flyout</code>
component is a dev-only component which just pretty prints the current state
on a full-screen overlay (toggled with <code>cmd+shift+s</code>. more on this in a future post).
But what happens when <code>put-upload</code> is called? How is <code>data</code> produced?</p>

<h4 id="handling-upload-events">Handling upload events</h4>

<p>The browser API docs and <a href="https://developer.mozilla.org/en/docs/Using_files_from_web_applications">examples</a> show that hidden away in the event object
(triggered on upload) is a list of files. From there a <code>FileReader</code> object can be
used to read from the file. The content is provided to the <code>onload</code> callback of
the <code>FileReader</code>.</p>

<p>To re-phrase all that: We need a callback to get the selected file and another
callback to get the contents of that file. Rather than do the nested callback dance,
which is all too familiar to most JS developers, let&rsquo;s use core.async!</p>
<div class="highlight"><pre><code class="language-clojure" data-lang="clojure"><span></span><span class="p">(</span><span class="k">def </span><span class="nv">first-file</span>
  <span class="p">(</span><span class="nb">map </span><span class="p">(</span><span class="k">fn </span><span class="p">[</span><span class="nv">e</span><span class="p">]</span>
         <span class="p">(</span><span class="k">let </span><span class="p">[</span><span class="nv">target</span> <span class="p">(</span><span class="nf">.-currentTarget</span> <span class="nv">e</span><span class="p">)</span>
               <span class="nv">file</span> <span class="p">(</span><span class="nb">-&gt; </span><span class="nv">target</span> <span class="nv">.-files</span> <span class="p">(</span><span class="nb">aget </span><span class="mi">0</span><span class="p">))]</span>
           <span class="p">(</span><span class="nf">set!</span> <span class="p">(</span><span class="nf">.-value</span> <span class="nv">target</span><span class="p">)</span> <span class="s">&quot;&quot;</span><span class="p">)</span>
           <span class="nv">file</span><span class="p">))))</span>

<span class="p">(</span><span class="k">def </span><span class="nv">extract-result</span>
  <span class="p">(</span><span class="nb">map </span><span class="o">#</span><span class="p">(</span><span class="nb">-&gt; </span><span class="nv">%</span> <span class="nv">.-target</span> <span class="nv">.-result</span> <span class="nv">csv/parse</span> <span class="nv">js-&gt;clj</span><span class="p">)))</span>

<span class="p">(</span><span class="k">def </span><span class="nv">upload-reqs</span> <span class="p">(</span><span class="nf">chan</span> <span class="mi">1</span> <span class="nv">first-file</span><span class="p">))</span>
<span class="p">(</span><span class="k">def </span><span class="nv">file-reads</span> <span class="p">(</span><span class="nf">chan</span> <span class="mi">1</span> <span class="nv">extract-result</span><span class="p">))</span>
</code></pre></div>

<p>All the browser interop is handled by two transducers <code>first-file</code> and <code>extract-result</code>.
Transducers capture the essence of computation independent of the input source and output
destination.</p>

<ul>
<li><code>first-file</code> accepts input change events and gets the first selected file. Also note that we
clear the target value. This allows re-uploading the same file.</li>
<li><code>extract-result</code> accepts a <code>FileReader</code> onload event, gets the string contents,
parses the CSV and converts the result to ClojureScript data structures.</li>
</ul>

<p>When it comes to parsing CSV we&rsquo;re in luck! The <code>csv/parse</code> function comes straight from the
built-in Google Closure library. You can find in the <code>goog.labs.format.csv</code> namespace.</p>

<p>Next we define two channels one for upload requests and the other for file read events.
When defining the channels we supply the corresponding transducers to handle the browser interop.
This means we can expect:</p>

<ul>
<li>taking from <code>upload-reqs</code> will produce file values</li>
<li>taking from <code>file-reads</code> will produce CSV as ClojureScript data structures</li>
</ul>

<p>All that&rsquo;s left is to wire up the channel logic so events flow through our channels.</p>
<div class="highlight"><pre><code class="language-clojure" data-lang="clojure"><span></span><span class="p">(</span><span class="kd">defn </span><span class="nv">put-upload</span> <span class="p">[</span><span class="nv">e</span><span class="p">]</span>
  <span class="p">(</span><span class="nf">put!</span> <span class="nv">upload-reqs</span> <span class="nv">e</span><span class="p">))</span>

<span class="p">(</span><span class="nf">go-loop</span> <span class="p">[]</span>
  <span class="p">(</span><span class="k">let </span><span class="p">[</span><span class="nv">reader</span> <span class="p">(</span><span class="nf">js/FileReader.</span><span class="p">)</span>
        <span class="nv">file</span> <span class="p">(</span><span class="nf">&lt;!</span> <span class="nv">upload-reqs</span><span class="p">)]</span>
    <span class="p">(</span><span class="nf">swap!</span> <span class="nv">app-state</span> <span class="nb">assoc </span><span class="ss">:file-name</span> <span class="p">(</span><span class="nf">.-name</span> <span class="nv">file</span><span class="p">))</span>
    <span class="p">(</span><span class="nf">set!</span> <span class="p">(</span><span class="nf">.-onload</span> <span class="nv">reader</span><span class="p">)</span> <span class="o">#</span><span class="p">(</span><span class="nf">put!</span> <span class="nv">file-reads</span> <span class="nv">%</span><span class="p">))</span>
    <span class="p">(</span><span class="nf">.readAsText</span> <span class="nv">reader</span> <span class="nv">file</span><span class="p">)</span>
    <span class="p">(</span><span class="nf">recur</span><span class="p">)))</span>

<span class="p">(</span><span class="nf">go-loop</span> <span class="p">[]</span>
  <span class="p">(</span><span class="nf">swap!</span> <span class="nv">app-state</span> <span class="nb">assoc </span><span class="ss">:data</span> <span class="p">(</span><span class="nf">&lt;!</span> <span class="nv">file-reads</span><span class="p">))</span>
  <span class="p">(</span><span class="nf">recur</span><span class="p">))</span>
</code></pre></div>

<p>We see <code>put-upload</code> is just a callback that puts to the <code>upload-reqs</code> channel.
The first go-loop is responsible for</p>

<ul>
<li>taking files from the <code>upload-reqs</code> channel</li>
<li>updating the <code>file-name</code> in the <code>app-state</code></li>
<li>creating a <code>FileReader</code> whose <code>onload</code> event puts to the <code>file-reads</code> channel</li>
<li>starting the file reading process</li>
</ul>

<p>In the second go-loop we just take the data structures off the <code>file-reads</code> channel
and swap them into the state.</p>

<h4 id="that-s-all-folks">That&rsquo;s all folks</h4>

<p>At this point all the hard stuff is done. The remaining implementation is all
problem specific. We have the CSV data in hand so all that remains is to build
the reagent component <code>[report data]</code> that renders it to the screen for viewing
and printing.</p>

      </article>
    </section>
    <div id="disqus_thread"></div>
<script type="text/javascript">
    var disqus_shortname = 'mrmcc3';
    var disqus_identifier = 'https:\/\/mrmcc3.github.io\/post\/csv-with-clojurescript\/';
    var disqus_title = 'Upload and parse CSV in ClojureScript';
    var disqus_url = 'https:\/\/mrmcc3.github.io\/post\/csv-with-clojurescript\/';

    (function() {
        var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
        dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
</script>
<noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
<a href="http://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
    <div class="copyright">
      This work is licensed under a Creative Commons Attribution-ShareAlike 4.0 International License.
    </div>
  </body>
</html>
